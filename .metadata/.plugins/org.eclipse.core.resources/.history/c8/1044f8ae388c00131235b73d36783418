package com.tvergilio.googleit;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;

import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteStatement;
import android.util.Log;

/**
 * A data access object for persisting and retrieving word data. This uses a
 * SQLite database for persistence and retrieval.
 * 
 */
public class WordDb extends SQLiteOpenHelper {
	private static final String TAG = "WordDb";
	// database metadata
	private static String DB_PATH = "/assets";
	private static final String DB_NAME = "words";
	private static final int DB_VERSION = 1;
	private static final String TABLE_NAME = "word";

	// column names
	private static final String NAME = "name";
	private static final String ID = "id";
	private static final String FIRST_SUGGESTION = "first_suggestion";
	private static final String SECOND_SUGGESTION = "second_suggestion";
	private static final String THIRD_SUGGESTION = "third_suggestion";

	// SQL statements
	private static final String CREATE_TABLE = "CREATE TABLE " + TABLE_NAME
			+ " (" + ID + " INTEGER PRIMARY KEY, " + NAME + " TEXT, "
			+ FIRST_SUGGESTION + " TEXT, " + SECOND_SUGGESTION + " TEXT, "
			+ THIRD_SUGGESTION + " TEXT)";
	private static final String INSERT_SQL = "INSERT INTO " + TABLE_NAME + " ("
			+ NAME + ", " + FIRST_SUGGESTION + "," + SECOND_SUGGESTION + ","
			+ THIRD_SUGGESTION + ",) " + "VALUES (?,?,?,?,?,?,?)";
	private static final String READ_SQL = "SELECT " + ID + ", " + NAME + ", "
			+ FIRST_SUGGESTION + ", " + SECOND_SUGGESTION + ", "
			+ THIRD_SUGGESTION + "" + " FROM " + TABLE_NAME;
	private static final String UPDATE_SQL = "UPDATE " + TABLE_NAME + " SET "
			+ FIRST_SUGGESTION + "=?, " + SECOND_SUGGESTION + "=?, "
			+ THIRD_SUGGESTION + "=? WHERE " + ID + "=?";

	// The Context object that created this WordDb
	private final Context context;
	// private final SQLiteOpenHelper helper;
	private SQLiteStatement stmt;
	private SQLiteStatement updateStmt;
	private SQLiteDatabase db;

	/**
	 * Constructor that takes a <code>Context</code> object, usually the
	 * <code>Service</code> or <code>Activity</code> that created this instance.
	 * This will initialize the SQLiteOpenHelper used for the database, and
	 * pre-compile the insert and update SQL statements.
	 * 
	 * @param ctx
	 *            The <code>Context</code> that created this instance
	 */
	public WordDb(Context ctx) {
		super(ctx, DB_NAME, null, 1);
		context = ctx;

	}

	@Override
	public void onCreate(SQLiteDatabase db) {
//		db.execSQL(CREATE_TABLE);
//		Log.d(TAG, "Created table: \n" + CREATE_TABLE);
	}
	
	 /**
     * Creates a empty database on the system and rewrites it with your own database.
     * */
    public void createDataBase() throws IOException{
 
    	boolean dbExist = checkDataBase();
 
    	if(dbExist){
    		//do nothing - database already exist
    	}else{
 
    		//By calling this method and empty database will be created into the default system path
               //of your application so we are gonna be able to overwrite that database with our database.
        	this.getReadableDatabase();
 
        	try {
 
    			copyDataBase();
 
    		} catch (IOException e) {
 
        		throw new Error("Error copying database");
 
        	}
    	}
 
    }
    
    /**
     * Check if the database already exist to avoid re-copying the file each time you open the application.
     * @return true if it exists, false if it doesn't
     */
    private boolean checkDataBase(){
 
    	SQLiteDatabase checkDB = null;
 
    	try{
    		String myPath = DB_PATH + DB_NAME;
    		checkDB = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READONLY);
 
    	}catch(SQLiteException e){
 
    		//database does't exist yet.
 
    	}
 
    	if(checkDB != null){
 
    		checkDB.close();
 
    	}
 
    	return checkDB != null ? true : false;
    }
    
    /**
     * Copies your database from your local assets-folder to the just created empty database in the
     * system folder, from where it can be accessed and handled.
     * This is done by transfering bytestream.
     * */
    private void copyDataBase() throws IOException{
 
    	//Open your local db as the input stream
    	InputStream myInput = context.getAssets().open(DB_NAME);
 
    	// Path to the just created empty db
    	String outFileName = DB_PATH + DB_NAME;
 
    	//Open the empty db as the output stream
    	OutputStream myOutput = new FileOutputStream(outFileName);
 
    	//transfer bytes from the inputfile to the outputfile
    	byte[] buffer = new byte[1024];
    	int length;
    	while ((length = myInput.read(buffer))>0){
    		myOutput.write(buffer, 0, length);
    	}
 
    	//Close the streams
    	myOutput.flush();
    	myOutput.close();
    	myInput.close();
 
    }
 
    public void openDataBase() throws SQLException{
 
    	//Open the database
        String myPath = DB_PATH + DB_NAME;
    	db = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READONLY);
 
    }
    
    @Override
   	public synchronized void close() {
    
       	    if(db != null)
       		    db.close();
    
       	    super.close();
    
   	}
 

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
		throw new UnsupportedOperationException();
	}

	/**
	 * Saves a <code>Word</code> to the database.
	 * 
	 * @param word
	 *            A <code>Word</code> instance that will be added to the
	 *            database.
	 * @return A <code>Word</code> instance with its data refreshed from the
	 *         database, including its database-assigned ID.
	 */
	public Word addWord(Word word) {
		Log.d(TAG, "Adding word to db, word=" + word);
		stmt.bindString(1, word.getName());
		stmt.bindString(2, word.getFirstSuggestion());
		stmt.bindString(3, word.getSecondSuggestion());
		stmt.bindString(4, word.getThirdSuggestion());
		int id = (int) stmt.executeInsert();
		return new Word(word, id);
	}

	/**
	 * Updates the current suggestions of a <code>Word</code> stored in the
	 * database.
	 * 
	 * @param word
	 *            The <code>Word</code> being updated.
	 */
	public void updateWordSuggestions(Word word) {
		Log.d(TAG, "Updating word suggestions in DB word=" + word.toString());
		updateStmt.bindString(1, word.getFirstSuggestion());
		updateStmt.bindString(2, word.getSecondSuggestion());
		updateStmt.bindString(3, word.getThirdSuggestion());
		updateStmt.bindLong(2, word.getId());
		updateStmt.execute();
	}

	/**
	 * Retrieve all of the <code>Word</code>s stored in the database.
	 * 
	 * @return List of all of the Words stored in the database.
	 */
	public ArrayList<Word> getWords() {
		Log.d(TAG, "Getting words form DB");
		Cursor results = db.rawQuery(READ_SQL, null);
		ArrayList<Word> words = new ArrayList<Word>(results.getCount());
		if (results.moveToFirst()) {
			int idCol = results.getColumnIndex(ID);
			int nameCol = results.getColumnIndex(NAME);
			int firstSuggestionCol = results.getColumnIndex(FIRST_SUGGESTION);
			int secondSuggestionCol = results.getColumnIndex(SECOND_SUGGESTION);
			int thirdSuggestionCol = results.getColumnIndex(THIRD_SUGGESTION);

			do {
				Word word = new Word(results.getString(nameCol),
						results.getString(firstSuggestionCol),
						results.getString(secondSuggestionCol),
						results.getString(thirdSuggestionCol));
				Log.d(TAG, "Word from db = " + word.toString());
				words.add(word);
			} while (results.moveToNext());
		}
		if (!results.isClosed()) {
			results.close();
		}
		return words;
	}



}